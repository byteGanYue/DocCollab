## 关于我

> [!TIP]
>
> 各位导师你好！我叫邓雄峰，广东海洋大学2026届的一名学生。就读于计算机科学与技术专业。
>
> 在大二下学期一次偶然的契机，我通过学校的实验室接触到了前端这个领域，并开始对前端产生了兴趣和持续学习至今，目前有两段实习经历。现在百度小度部门t0前端团队担任前端开发实习生，主要负责的内容是小度app H5页面、小度官网的维护和小度智能家居IOT设备相关业务。
>
> 曾就职于杭州玳数有限公司，担任前端开发实习生，主要负责低代码构建可视化大屏项目，组件开发，工程化构建等工作。
>
> 个人比较关心前端，热爱开源，喜欢发表个人学习相关的技术文章，关心各大开源社区。

## 本次训练营项目负责的内容实现和收益

### 项目管理规范和工程化落地

---

根据第一节周会王宝同导师的分享，我对项目进行了严格高效的管理，在整个项目开发过程中没有放过**任何一行需检测代码**

![image-20250707224124119](./image/image-20250707224124119.png)

- **提交规范** - 通过 `Husky` 编写 `Shell` 脚本，严格规范提交信息、代码风格，并且实现 `commit` 图标美化

- **项目管理** - 采用 `Monorepo` 架构，便于用户一键启动项目，使用 `pnpm workspace` 进行依赖管理

- **文档完善** - 利用 `vitepress` 结合 `github action` + `github Pages` 部署的详细使用文档 

  

### 开发效率提高

----



- **构建优化** - 利用 `Turbo` 缓存机制和并行处理任务实现高性能构建，`CI` **时间减少约 70%**，大大开发效率
- **项目复用性** - 整个项目采用本地依赖包管理方式开发，实现一个可以**开箱即用**的slate编辑器组件，减少和web项目耦合度，提高**复用性和实用性**



### 具体项目核心负责的内容

---

**Doc-editor（开箱即用的协同编辑器组件）：**

- 协同方案调研和编辑器需求开发

  - ot（操作变换） 和 crdt（无冲突复制） 算法
    - yjs（网络提供者（Network Providers））

- 协同编辑划词评论  

  - 脏路径问题：使用Yjs相对位置系统，评论位置随文档编辑自动调整

  - **Doc-editor（开箱即用的协同编辑器组件）：**

    - 协同方案调研和编辑器需求开发

      - ot（操作变换） 和 crdt（无冲突复制） 算法
        - yjs（只需要关注数据如何操作，网络提供者（Network Providers））

    - 协同编辑划词评论  

      - 协同评论功能实现方案总结：

        1. **核心架构**：

        - 基于Yjs的协同编辑框架实现
        - 使用Y.Array存储评论数据，确保多端同步
        - 结合Slate编辑器实现评论标记和显示

        1. **关键技术点**：

        - **评论定位**：使用Yjs相对位置系统(Y.createRelativePositionFromTypeIndex)解决文档编辑导致的**评论漂移**问题

        ```javascript
          // 添加评论方法
          const addComment = useCallback((startIndex, endIndex, content, author) => {
            if (!yCommentsRef.current || !yTextRef.current || !editorRef.current) {
              console.error('Comments, text reference or editor not initialized');
              return;
            }
        
            try {
              const editor = editorRef.current;
        
              // 保存当前选区
              const savedSelection = editor.selection;
        
              // 使用全局索引找到对应的 Slate 范围
              let count = 0;
              let anchor = null;
              let focus = null;
        
              for (const [node, path] of Node.texts(editor)) {
                const len = Node.string(node).length;
                if (anchor === null && count + len >= startIndex) {
                  anchor = { path, offset: startIndex - count };
                }
                if (focus === null && count + len >= endIndex) {
                  focus = { path, offset: endIndex - count };
                  break;
                }
                count += len;
              }
        
              if (!anchor || !focus) {
                console.error('Failed to find text range for comment');
                return;
              }
        
              // 设置选区到要评论的文本
              const commentRange = { anchor, focus };
              Transforms.select(editor, commentRange);
        
              // 生成唯一的评论ID
              const commentId = Date.now().toString();
        
              // 直接添加评论标记到选中的文本
              Editor.addMark(editor, 'comment', {
                id: commentId,
                content,
                author,
                time: Date.now(),
              });
        
              // 恢复原始选区
              if (savedSelection) {
                Transforms.select(editor, savedSelection);
              }
        
              // 清除编辑器的活动标记状态，防止影响后续输入
              // 注意：这里只清除活动标记，不影响已经应用到文本节点上的标记
              editor.marks = null;
        
              // 延迟清除活动标记，确保不影响后续输入
              setTimeout(() => {
                editor.marks = null;
              }, 0);
        
              console.log('Comment added successfully');
        
              // 同时也保存到 Yjs 数组中以便协同
              if (startIndex !== undefined && endIndex !== undefined) {
                // 确保索引在有效范围内
                const validStartIndex = Math.max(
                  0,
                  Math.min(startIndex, yTextRef.current.length),
                );
                const validEndIndex = Math.max(
                  validStartIndex,
                  Math.min(endIndex, yTextRef.current.length),
                );
        
                // 创建相对位置
                const start = Y.createRelativePositionFromTypeIndex(
                  yTextRef.current,
                  validStartIndex,
                );
                const end = Y.createRelativePositionFromTypeIndex(
                  yTextRef.current,
                  validEndIndex,
                );
        
                if (start && end) {
                  const startJSON = JSON.stringify(start);
                  const endJSON = JSON.stringify(end);
        
                  // 添加评论到 Yjs 数组
                  yCommentsRef.current.push([
                    {
                      id: commentId,
                      start: startJSON,
                      end: endJSON,
                      content,
                      author,
                      time: Date.now(),
                    },
                  ]);
                }
              }
            } catch (error) {
              console.error('Error adding comment:', error);
            }
          }, []);
        ```

        ```javascript
        // 删除评论方法
          const removeComment = useCallback(
            commentId => {
              try {
                if (!editor || !commentId) {
                  console.error('Editor or commentId is missing');
                  return;
                }
        
                console.log('Removing comment:', commentId);
        
                // 保存当前选区
                const { selection } = editor;
        
                // 1. 从 Slate 编辑器中移除评论标记
                // 遍历所有文本节点，找到包含指定评论ID的节点并移除标记
                const nodesToUpdate = [];
                for (const [node, path] of Node.texts(editor)) {
                  if (node.comment && node.comment.id === commentId) {
                    nodesToUpdate.push(path);
                  }
                }
        
                // 批量移除评论标记
                for (const path of nodesToUpdate) {
                  try {
                    // 方法1: 使用 Transforms.unsetNodes 移除 comment 属性
                    Transforms.unsetNodes(editor, 'comment', {
                      at: path,
                      match: n =>
                        Text.isText(n) && n.comment && n.comment.id === commentId,
                    });
        
                    // 方法2: 直接操作节点属性（备用方案）
                    const node = Node.get(editor, path);
                    if (
                      Text.isText(node) &&
                      node.comment &&
                      node.comment.id === commentId
                    ) {
                      // 创建新的节点，不包含 comment 属性
                      const { comment, ...nodeWithoutComment } = node;
                      Transforms.setNodes(editor, nodeWithoutComment, { at: path });
                    }
                  } catch (error) {
                    console.warn(
                      'Failed to remove comment from node at path:',
                      path,
                      error,
                    );
                  }
                }
        
                // 2. 清除编辑器中的活动标记，防止影响后续输入
                // 这是关键步骤：确保光标位置不会继承评论标记
                if (editor.marks && editor.marks.comment) {
                  delete editor.marks.comment;
                }
        
                // 强制移除所有评论相关的活动标记
                Editor.removeMark(editor, 'comment');
        
                // 3. 从 Yjs 评论数组中移除评论数据
                // 注意：Yjs 数组中的评论数据结构可能不同，需要检查多种可能的 ID 字段
                if (yCommentsRef.current) {
                  const yCommentsArray = yCommentsRef.current.toArray();
                  for (let i = yCommentsArray.length - 1; i >= 0; i--) {
                    const comment = yCommentsArray[i];
                    // 检查不同可能的 ID 字段和数据结构
                    const commentToCheck = Array.isArray(comment)
                      ? comment[0]
                      : comment;
                    if (
                      commentToCheck &&
                      (commentToCheck.id === commentId ||
                        (commentToCheck.content &&
                          commentToCheck.author &&
                          JSON.stringify(commentToCheck).includes(commentId)))
                    ) {
                      yCommentsRef.current.delete(i, 1);
                      console.log('Removed comment from Yjs array at index:', i);
                      break;
                    }
                  }
                }
        
                // 4. 恢复原始选区并确保清除标记状态
                if (selection) {
                  Transforms.select(editor, selection);
                  // 再次确保当前选区没有评论标记
                  Editor.removeMark(editor, 'comment');
                }
        
                // 5. 强制重新规范化编辑器，确保所有标记都被清除
                Editor.normalize(editor, { force: true });
        
                // 6. 强制触发编辑器重新渲染
                editor.onChange();
        
                // 7. 延迟再次清除活动标记，确保彻底清除
                setTimeout(() => {
                  if (editor.marks && editor.marks.comment) {
                    delete editor.marks.comment;
                  }
                  Editor.removeMark(editor, 'comment');
                }, 0);
        
                console.log('Comment removed successfully');
              } catch (error) {
                console.error('Error removing comment:', error);
              }
            },
            [editor],
          );
        ```

        关键实现说明：

        1. **双重定位系统**：

        - Slate路径定位：用于当前编辑器实例中的快速渲染
        - Yjs相对位置：用于跨客户端同步和文档修改时的位置保持

        1. **漂移问题解决**：

        ```javascript
        // 当文档修改后，通过相对位置可以正确找到评论位置
        const absPos = Y.createAbsolutePositionFromRelativePosition(
          JSON.parse(comment.start), 
          docRef.current
        );
        // absPos包含最新的正确位置信息
        ```

        **主要方法**：

        - `addComment`：添加评论到指定文本范围
        - `removeComment`：删除指定ID的评论
        - 评论数据实时同步到所有客户端


**doc-docs（项目介绍文档）：**

- 介绍文档具体内容撰写
- AI理解文档能力增强：集成 LLM（大语言模型）友好的文档格式（傻瓜ai也能快速读懂的文档）

**doc-web（项目前端）：**

- 整体项目基础demo构建和布局
- 一些页面page开发和维护

**doc-server（项目后端）：**

- 数据库和数据结构设计
- 数据库配置登录注册模块
- api文档集成

## 个人心得
感谢飞书训练营导师们的专业指导和团队伙伴们的通力合作。参与DocCollab协同文档系统的开发让我获得了全方位的成长，接触到很多新领域，比如Slate-Yjs协同编辑框架和CRDT冲突解决算法，还通过项目管理、Git协作规范等实践提升了工程化能力。从需求分析到架构设计再到最终实现的完整流程，让我对企业级项目开发有了更深刻的理解。特别感谢训练营精心设计的渐进式挑战，这些实战经验不仅强化了我的技术深度，更培养了我解决复杂问题的系统思维，这段经历将成为我职业发展道路上的宝贵财富。

